// Package template provides template functions and management for CronAI.
package template

import (
	"encoding/json"
	"fmt"
)

// JSONEscape escapes the given string for safe inclusion in JSON
// Deprecated: Use json.Marshal on the entire object instead of manually constructing JSON strings
func JSONEscape(s string) string {
	b, err := json.Marshal(s)
	if err != nil {
		// This shouldn't happen for strings, but if it does, return a safe version
		return fmt.Sprintf("%q", s)
	}
	// Remove the surrounding quotes that json.Marshal adds
	return string(b[1 : len(b)-1])
}

// marshalToJSON is a helper function to convert a map to a JSON string
func marshalToJSON(data map[string]interface{}, fallbackTitle string) string {
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		// Provide simple fallback if marshaling fails
		if fallbackTitle != "" {
			escapedTitle, titleErr := json.Marshal(fallbackTitle)
			if titleErr != nil {
				// If even the fallback title can't be marshaled, use a generic fallback
				return `{"title":"Unknown","body":"Error generating JSON"}`
			}
			// Remove surrounding quotes from the marshaled string
			return fmt.Sprintf(`{"title":%s,"body":"Error generating JSON"}`, escapedTitle)
		}
		return `{"body":"Error generating JSON"}`
	}
	return string(jsonBytes)
}

// GitHubIssueTemplate returns a JSON structure for a GitHub issue
func GitHubIssueTemplate(data Data) string {
	title := fmt.Sprintf("%s - %s", data.PromptName, data.Metadata["date"])

	// Format variables section
	variablesSection := ""
	if len(data.Variables) > 0 {
		variablesSection = "### Variables\n"
		for k, v := range data.Variables {
			variablesSection += fmt.Sprintf("- %s: %s\n", k, v)
		}
	}

	// Format body with proper JSON escaping
	body := fmt.Sprintf("## Generated by CronAI\n\n"+
		"**Model**: %s\n"+
		"**Timestamp**: %s\n"+
		"**Execution ID**: %s\n\n"+
		"%s\n"+
		"### Content\n\n"+
		"%s\n\n"+
		"---\n"+
		"_Generated by CronAI using %s model_",
		data.Model,
		data.Timestamp.Format("Jan 02, 2006 15:04:05"),
		data.ExecutionID,
		variablesSection,
		data.Content,
		data.Model)

	// Create structured data for JSON serialization
	issueData := map[string]interface{}{
		"title":  title,
		"body":   body,
		"labels": []string{"auto-generated", "cronai"},
	}

	return marshalToJSON(issueData, title)
}

// GitHubCommentTemplate returns a JSON structure for a GitHub comment
func GitHubCommentTemplate(data Data) string {
	// Format body with proper JSON escaping
	body := fmt.Sprintf("## AI Response\n\n"+
		"**Model**: %s\n"+
		"**Timestamp**: %s\n"+
		"**Prompt**: %s\n\n"+
		"%s\n\n"+
		"---\n"+
		"_Generated by CronAI using %s model_",
		data.Model,
		data.Timestamp.Format("Jan 02, 2006 15:04:05"),
		data.PromptName,
		data.Content,
		data.Model)

	// Create structured data for JSON serialization
	commentData := map[string]interface{}{
		"body": body,
	}

	return marshalToJSON(commentData, "")
}

// GitHubPRTemplate returns a JSON structure for a GitHub pull request
func GitHubPRTemplate(data Data) string {
	title := fmt.Sprintf("%s - %s", data.PromptName, data.Metadata["date"])

	// Format variables section
	variablesSection := ""
	if len(data.Variables) > 0 {
		variablesSection = "### Variables\n"
		for k, v := range data.Variables {
			variablesSection += fmt.Sprintf("- %s: %s\n", k, v)
		}
	}

	// Format body with proper JSON escaping
	body := fmt.Sprintf("## Generated by CronAI\n\n"+
		"**Model**: %s\n"+
		"**Timestamp**: %s\n"+
		"**Execution ID**: %s\n\n"+
		"%s\n"+
		"### Content\n\n"+
		"%s\n\n"+
		"---\n"+
		"_Generated by CronAI using %s model_",
		data.Model,
		data.Timestamp.Format("Jan 02, 2006 15:04:05"),
		data.ExecutionID,
		variablesSection,
		data.Content,
		data.Model)

	// Get head branch from variables or default
	headBranch := data.Variables["head_branch"]
	if headBranch == "" {
		headBranch = "feature-branch"
	}

	// Get base branch from variables or default to main
	baseBranch := data.Variables["base_branch"]
	if baseBranch == "" {
		baseBranch = "main"
	}

	// Create structured data for JSON serialization
	prData := map[string]interface{}{
		"title": title,
		"body":  body,
		"head":  headBranch,
		"base":  baseBranch,
	}

	return marshalToJSON(prData, title)
}
